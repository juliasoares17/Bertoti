Atividade 1:

"We see three critical differences between programming and software engineering: time, scale, and the trade-offs at play. On a software engineering project, engineers need to be more concerned with the passage of time and the eventual need for change. In a software engineering organization, we need to be more concerned about scale and efficiency, both for the software we produce as well as for the organization that is producing it. Finally, as software engineers, we are asked to make more complex decisions with higher-stakes outcomes, often based on imprecise estimates of time and growth."

Por meio do texto acima, é possível concluir que a Engenharia de Software exige coragem, eficiência e conhecimento. É necessário trabalhar buscando criar um produto excelente no menor tempo possível, visto que o mercado das tecnologias é extremamente impreciso, e uma novidade mínima pode gerar a necessidade de refazer um projeto por completo. Além disso, muitas vezes, as noções de tempo e esforço necessários para cumprir certas tarefas não são precisas, o que exige coragem por parte dos trabalhadores para dedicarem-se totalmente ao projeto, buscando, novamente, concluir suas obrigações o mais rápido possível. Por outro lado, o conhecimento pode ajudar a resolver o problema explicado anteriormente. Profissionais que conhecem uma grande diversidade métodos e ferramentas, saberão sair de situações problemáticas com mais facilidade, pois sempre há uma ferramenta ou um processo que funciona melhor para uma certa problemática. Todos esses fatores, unidos, formam um profissional de engenharia de software extremamente capacitado, visto que trata-se de uma área imprevisível, e não se deixar abalar por mudanças inesperadas é essencial para lidar com ela. 

"Within Google, we sometimes say, 'Software engineering is programming integrated over time.' Programming is certainly a significant part of software engineering: after all, programming is how you generate new software in the first place. If you accept this distinction, it also becomes clear that we might need to delineate between programming tasks (development) and software engineering tasks (development, modification, maintenance). The addition of time adds an important new dimension to programming. Cubes aren’t squares, distance isn’t velocity. Software engineering isn’t programming."

Após a leitura desse segundo texto, percebe-se que seu principal obejtivo é diferenciar programação de engenharia de software, mas ainda deixando claro que elas estão relacionadas. Programar é uma parte da engenharia de software, pois representa o processo de desenvolvimento, mas esta área ainda envolve os atos de modificar e sustentar, diferentemente da programação. Além de criar, engenheiros de software também são responsáveis por realizar mudanças constantemente e manter o software funcionando. É por meio deste fator que a engenharia de software se diferencia da programação e prova-se tão importante quanto.

Atividade 2:

Comparando duas tecnologias em relação a requisitos não-funcionais:

Figma e Photoshop (ambas tecnologias de design gráfico).

Para aqueles que não possuem tanta experiência no design gráfico, o Photoshop pode parecer mais complexo, enquanto o Figma destaca-se por maior facilidade de uso devido à sua interface mais simples. No entanto, é interessante considerar que, apesar de ambos serem ferramentas de design gráfico, o Figma e o Photoshop possuem públicos-alvos e propósitos diferentes. O Photoshop é mais adequado para edições profissionais de fotografias, criação de logos e imagens para publicidade, enquanto o Figma é ideal para designers, desenvolvedores web e empresas de todos os tamanhos e segmentos com necessidades de peças de marketing e de protótipos visuais. É essencial levar isso em considerção quando for necessário escolher uma das duas tecnologias. Também é possível discutir o aspecto do desempenho. O desempenho do Figma pode variar dependendo da conexão à internet e da carga do servidor, apesar do programa ser geralmente otimizado para rodar de forma suave em navegadores modernos e em diferentes sistemas operacionais. Já o Photoshop, por ser uma aplicação nativa de desktop, tende a oferecer um desempenho consistente, independentemente da conexão à internet, desde que o hardware do computador seja adequado. Em contraponto, ele pode exigir mais recursos do sistema, como memória RAM e capacidade de processamento gráfico. Partindo para outro tópico, por ser baseado em nuvem, o Figma é acessível de qualquer dispositivo com um navegador e conexão à internet. Ele é multiplataforma, funcionando em Windows, macOS e Linux, e não requer instalação local. Enquanto isso, o Photoshop é um software de desktop que precisa ser instalado em cada dispositivo. Ele está disponível para Windows e macOS, mas não para Linux. É necessário estar vinculado à conta da Adobe Creative Cloud para acessá-lo em diferentes dispositivos, e a instalação pode ser uma barreira de acessibilidade. Por fim, é interessante abordar o custo de ambas as ferramentas. O Figma oferece uma versão gratuita com funcionalidades limitadas e versões pagas com funcionalidades adicionais, enquanto o Photoshop é parte do Adobe Creative Cloud, e normalmente requer uma assinatura paga. O custo é geralmente mais elevado que o do Figma, especialmente se outras ferramentas da Adobe forem necessárias. Diante do exposto, torna-se possível concluir que o Figma é ideal quando o usuário prioriza acessibilidade e simplicidade no design de interfaces digitais, especialmente se buscar uma ferramenta baseada em nuvem e que seja mais fácil de compreender. A partir disso, o Photoshop torna-se mais adequado para profissionais que necessitem de um controle detalhado sobre edição de imagens, arte digital ou design gráfico, com desempenho consistente em desktop e uma ampla gama de funcionalidades, apesar da necessidade de conhecimento e do custo serem mais elevados.

Notion e Evernote (ambas ferramentas de produtividade e organização)

Primeiramente, por ser uma ferramenta que combina notas, bancos de dados e wikis, o Notion pode apresentar variações de desempenho dependendo da complexidade das páginas e do volume de dados. Em dispositivos móveis, pode ser um pouco mais lento ao carregar conteúdos extensos ou imagens. A performance também pode depender da conexão à internet, pois é uma aplicação baseada em nuvem. Já o Evernote, como uma aplicação de notas tradicional, é geralmente estável e bem otimizado, principalmente em dispositivos móveis e desktops. Quanto à acessibilidade, o Notion é uma ferramenta que está disponível para múltiplas plataformas, incluindo web, iOS, Android, Windows, e macOS. A experiência de uso é muito consistente entre as plataformas, e as informações são sincronizadas automaticamente. O Evernote também é acessível para várias plataformas (Windows, macOS, iOS, Android), com sincronização automática entre dispositivos, e possui a vantagem de um suporte offline mais robusto, permitindo que os usuários acessem e editem suas notas sem conexão à internet (a sincronização automática funciona normalmente quando o usuário reconecta-se, guardando as alterações feitas e refletindo-as em todos os dispositivos conectados à mesma conta). Ao abordar questões relacionadas a custo, é necessário reconhecer que, apesar de possuir funcionalidades limitadas, o plano gratuito oferecido pelo Notion é suficiente para a maioria dos usuários individuais. Os planos pagos são mais adequados para profissionais que necessitem de recursos como permissões avançadas e maior capacidade de armazenamento. O plano gratuito do Evernote, por outro lado, possui limitações mais rígidas em comparação ao Notion, como o número de dispositivos sincronizados e o tamanho máximo de upload. Os planos pagos podem ser mais caros, especialmente para usuários que precisam de acesso offline completo ou funcionalidades avançadas. Finalmente, o Notion pode "ensinar" mais a pessoas inexperientes do que o Evernote, especialmente devido à sua flexibilidade e às diversas funcionalidades que ele oferece. Criar e personalizar páginas pode exigir algum tempo para se acostumar, mas a personalização é uma grande vantagem. O Evernote é uma ferramenta mais direta e focada em notas simples, sem grandes surpresas. É fácil de adotar para quem está começando, mas acaba sendo mais adequada para quem já está acostumado com outras ferramentas de anotação. Em suma, o Notion é uma ferramenta poderosa para aqueles que buscam um ambiente altamente personalizável para notas, tarefas e gerenciamento de projetos, apesar de exigir um pouco mais de tempo para se acostumar, enquanto o Evernote é ideal para usuários que precisam de uma solução mais simples e direta para organização pessoal, com foco em anotações e uma experiência offline robusta, por mais que seja menos flexível e mais caro em seus planos premium.

Zoom e Google Meet (ambas ferramentas de videoconferência).

Iniciando essa comparação pelo desempenho de ambas as ferramentas,o Zoom é conhecido por ser estável e suportar reuniões com um grande número de participantes. Ele funciona bem em várias condições de rede, adaptando automaticamente a qualidade do vídeo para manter a estabilidade, e, inclusive, possui suporte offline para a gravação de reuniões locais. Porém, o uso intensivo de CPU e RAM durante reuniões longas ou com múltiplos participantes em vídeo pode impactar o desempenho em dispositivos menos potentes. O Google Meet também oferece execução sólida e se adapta bem à qualidade da rede, e o consumo de recursos é geralmente menor que o do Zoom, mas pode apresentar limitações em chamadas com muitos participantes ou se várias abas ou aplicativos do Google estiverem abertos simultaneamente. Ao abordar a questão da acessibilidade, é possível afirmar que o Zoom está disponível para múltiplas plataformas, como Windows, macOS, iOS e Android. Contudo, apesar de ser possível acessá-lo tanto via aplicativo dedicado quanto via navegador, a experiência completa requer o aplicativo. O Google Meet, por sua vez, pode ser acessado de forma mais simples, visto que não necessita da instalação de nenhum software, apenas do uso de um navegador. Está disponível para Windows, macOS, iOS, e Android, além de integrar-se bem com o Google Calendar e o Gmail, o que é um grande benefício para usuários do Google Workspace. A desvantagem está no fato de que o acesso total a algumas funcionalidades pode estar limitado ao ecossistema do Google. Partindo para o tópico "custo", o Zoom possui um plano gratuito com reuniões limitadas a 40 minutos para grupos, e planos pagos com preços variados dependendo do número de hosts e funcionalidades adicionais. Para grandes organizações, o Zoom pode tornar-se caro, especialmente com a necessidade de add-ons para funcionalidades avançadas. Incluso em todos os planos do Google Workspace, o Google Meet também oferece uma versão gratuita que possui a vantagem de um limite de tempo maior para reuniões em grupo (60 minutos). Para usuários do Google Workspace, o Meet pode ser uma solução mais econômica, já que não requer uma assinatura separada. Por fim, qual dos dois é fácil de utilizar e compreender? Com uma interface intuitiva que permite aos usuários agendar, iniciar e participar de reuniões com facilidade, o Zoom é relativamente entendível, apesar das funcionalidades avançadas exigirem algum treinamento. Tratando-se do Google Meet, sua interface é muito simples e direta, especialmente clara para quem já está familiarizado com outras ferramentas do Google. A integração com o Google Calendar torna a organização de reuniões simples, e usuários do Google Workspace acabam possuindo experiência suficiente para compreendê-lo. Conclui-se, diante do discutido acima, que o Zoom é uma ferramenta versátil e rica em funcionalidades, ideal para empresas e organizações que necessitam de uma solução robusta para grandes reuniões e sessões de colaboração detalhadas, embora possa ter um custo mais elevado e exigir mais recursos de hardware. O Google Meet é mais adequado para aqueles que já utilizam o ecossistema do Google, oferecendo uma solução integrada, econômica e fácil de usar para videoconferências cotidianas, com um desempenho sólido e uma necessidade de aprendizado quase inexistente.

Atividade 3:

Analisando a arquitetura do Reddit:

https://x.com/alexxubyte/status/1795825665016787324 (Referência)

Escalabilidade:
É possível começar essa análise explicando que a arquitetura do Reddit é organizada em microserviços, ou seja, diferentes partes do sistema funcionam de forma independente, mas colaboram para fornecer dados aos utilizadores. Em vez de haver um único ponto central para lidar com todos os pedidos de dados, cada serviço específico pode ser ampliado separadamente conforme necessário. Dando continuidade, essa arquitetura é federada por GraphQL, que é uma linguagem de consulta para APIs que permite que os clientes peçam exatamente os dados dos quais precisam, e em que formato precisam. Isso torna a troca de informações entre o frontend e o backend mais eficiente. 
Por fim, a utilização de uma rede como a Fastly e da tecnologia de load balancer permite que o conteúdo do Reddit (como imagens, vídeos e páginas) seja distribuído de forma equilibrada para vários servidores ao redor do mundo, e, quando alguém acessa a rede social, o conteúdo é carregado a partir do servidor mais próximo dessa pessoa, o que torna o carregamento mais rápido e eficiente e evita sobrecargas em servidores individuais, mesmo com muitos utilizadores ao mesmo tempo. Embora escalável, a complexidade da arquitetura do Reddit aumenta com a necessidade de coordenar múltiplos serviços federados, o que pode introduzir latências adicionais.

Segurança:
Quanto à questão da segurança, a infraestrutura do Reddit está hospedada na AWS e é gerida pelo Kubernetes, o que leva ela a fornecer mecanismos robustos de segurança, como autenticação, autorização e monitoramento. Somado a isso, o uso de GraphQL permite que a segurança seja gerida de forma centralizada em pontos específicos do sistema, onde é possível controlar detalhadamente quem pode acessar quais dados. Isso significa que o Reddit pode definir, de maneira muito precisa, quais utilizadores têm permissão para ver ou modificar diferentes partes das informações na plataforma.
No entanto, a grande quantidade de serviços expostos pode aumentar a superfície de ataque, exigindo medidas de segurança severas em cada ponto de interação.

Consistência:
O Cassandra é utilizado para armazenar dados de forma distribuída, enquanto o PostgreSQL é usado para transações. O PostgreSQL garante que todas as operações sejam concluídas corretamente e os dados permaneçam seguros e consistentes, mas o Cassandra oferece uma consistência que pode demorar um pouco para se estabilizar. Devido a esse fator, algumas operações podem ter consistência eventual, o que pode ser problemático em cenários que exigem consistência forte.

Flexibilidade:
A arquitetura modular do Reddit facilita a adição e a remoção de serviços conforme as necessidades mudam. Servidores podem ser adicionados ou removidos conforme demanda, e isso permite que a plataforma siga rápida e responsiva, mesmo durante picos de tráfego ou falhas em servidores individuais. Ademais, a utilização de GraphQL permite uma grande flexibilidade na maneira como os dados são requisitados e agregados, pois ele facilita o agrupamento de dados de várias fontes diferentes, sendo possível personalizar as respostas conforme necessário. 
Apesar de alta, essa flexibilidade pode ser limitada pela necessidade de garantir a integração e a comunicação eficientes entre múltiplos serviços.

Performance:
A inclusão de caches com Memcached pode reduzir a latência das operações mais comuns, o que melhora o desempenho geral. O Memcached é um sistema de cache em memória de alto desempenho. Ele é usado para armazenar dados temporariamente na memória RAM, o que permite o acesso a tais dados de forma muito rápida. Isso é especialmente útil para que o Reddit possa funcionar adequadamente para usuários que acessam informações frequentemente, reduzindo a necessidade de consultar um banco de dados ou uma API repetidamente. De forma complementar, novamente, o uso de load balancer e Fastly evita sobrecargas e mantém o rápido desempenho do site. 
Apesar desses fatores que contribuem para que o Reddit seja caracterizado por um bom desempenho, a comunicação entre múltiplos serviços pode introduzir overhead, especialmente se as chamadas forem síncronas e frequentes.

Qualidade:
O uso de ferramentas de deployment, ou seja, programas ou plataformas que automatizam e gerenciam o processo de tornar um software disponível para os utilizadores, como Spinnaker e Terraform, garante que as atualizações do Reddit sejam implementadas de forma consistente e com alta qualidade. Além disso, por meio do uso de soluções como Prometheus, a qualidade do serviço da plataforma pode ser constantemente monitorada e ajustada conforme necessário. O único porém para a qualidade do Reddit é que a dificuldade de manutenção está presente como um problema dessa arquitetura.

Velocidade:
O uso de tecnologias modernas como TypeScript e jQuery no frontend do Reddit contribui para a velocidade de interação e carregamento da interface, o uso de cache com Memcached e da Fastly otimizam a velocidade de resposta da plataforma e, para completar a parte positiva, a utilização de job workers assíncronos (programas que realizam tarefas em segundo plano, independentemente da execução principal de uma aplicação) melhora a capacidade do sistema de lidar com tarefas demoradas sem impactar a experiência do utilizador. Como ponto negativo, há o fato de que pode ser possível reconhecer latência pela necessidade de coordenação entre diferentes microserviços.

Confiabilidade:
A arquitetura distribuída, juntamente com o uso do Kubernetes, garante que o Reddit mantenha alta disponibilidade e confiabilidade. O Kubernetes gerencia automaticamente os recursos, redimensiona a infraestrutura conforme necessário e substitui rapidamente qualquer parte que falhe, evitando interrupções. Logo, mesmo em caso de problemas técnicos, o Reddit pode continuar funcionando sem que os utilizadores percebam falhas.
Apesar dos aspectos positivos, a confiabilidade do Reddit acaba sendo dependente da infraestrutura fornecida por terceiros, como a AWS e a Fastly, o que pode ser um ponto de falha externa.

Conclusão:
A arquitetura do Reddit reflete uma série de compromissos bem calculados entre os diferentes aspetos não-funcionais, apesar das concessões em áreas como consistência estrita e simplicidade operacional. O uso do Cassandra e de sistemas de cache como Memcached destaca a prioridade dada à velocidade de resposta, essencial para uma grande base de utilizadores, mesmo que isso implique aceitar algum grau de inconsistência. Ao mesmo tempo, a segurança é garantida por meio de autenticação, autorização e controle de acesso baseado em funções, proporcionando proteção robusta dos dados dos utilizadores sem sacrificar a flexibilidade necessária para um desenvolvimento ágil. Além disso, a utilização de DevOps e ferramentas de automação de infraestrutura, juntamente com metodologias ágeis, permite ao Reddit lançar novas funcionalidades rapidamente, mantendo a qualidade do produto com práticas rigorosas de revisão de código e monitoramento contínuo. Finalmente, é possível afirmar que o Reddit possui uma arquitetura que condiz com as propostas da plataforma. Os desafios relacionados à complexidade, consistência e latência precisam ser geridos com cuidado, mas eles não impedem os usuários do Reddit de terem uma experiência agradável ao interagir com a rede social. É possível divertir-se e informar-se sem grandes complicações.


Atividade 4:

Classes UML e código Java
Contexto: Classes necessárias para construir um sistema de gestão de um restaurante.

(O diagrama de classes UML está na pasta Imagens)

Código Java:
Classe Prato: 
public class Prato {
    private String nome;
    private double preço;
    private String descrição;
    
    public Prato(String nome, double preço, String descrição) {
        this.nome = nome;
        this.preço = preço;
        this.descrição = descrição;
    }
    
    public String getNome(){
        return "Nome: " + nome;
    }
    
    public String getPreco(){
        return "Preço: " + preço;
    }
            
    public String getDescricao(){
        return "Descrição: " + descrição;
    }
   
    void atualizarPreco(double novoPreço){
        this.preço = novoPreço;
    }
    
    void atualizarNome(String novoNome){
        this.nome = novoNome;
    }
    
    void atualizarDescricao(String novaDescrição){
        this.descrição = novaDescrição;
    }
   }

Classe Pedido:
import java.util.ArrayList;
import java.util.List;

public class Pedido {
    private int id;
    private String data;
    private List<Prato> pratos;
    
    public Pedido(int id, String data){
        this.id = id;
        this.data = data;
        this.pratos = new ArrayList<>();
    }
    
    public double calcularTotal(){
        return pratos.stream().mapToDouble(Prato::getPreco).sum();
    }
    
    void adicionarPrato(Prato prato){
        pratos.add(prato);
    }
    
    void removerPrato(Prato prato){
        pratos.remove(prato);
    }
    
    public String getId(){
        return "Id: " + id;
    }
    
    public String getData(){
        return "Data: " + data;
    }
    
    public List<Prato> getPratos(){
        return pratos;
    }
}

Classe Cliente:
import java.util.ArrayList;
import java.util.List;

public class Cliente {
    private String nome;
    private String contato;
    private List<Pedido> pedidos;
    
    public Cliente(String nome, String contato) {
        this.nome = nome;
        this.contato = contato;
        this.pedidos = new ArrayList<>();
    }
    
    public String getNumeroDePedidos(){
        return "Número de pedidos: " + pedidos.size();
    }
    
    public String getNome(){
        return "Nome: " + nome;
    }
    
    public String getContato(){
        return "Contato: " + contato;
    }
    
    public List<Pedido> getPedidos(){
        return pedidos;
    }
    
    void adicionarPedido(Pedido pedido){
        pedidos.add(pedido);
    }
    
    void atualizarContato(String novoContato){
        this.contato = novoContato;
}
}
